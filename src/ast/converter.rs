//! Core instruction-to-expression conversion system
//!
//! This module provides the main InstructionToExpressionConverter that transforms
//! Hermes bytecode instructions into OXC AST expressions using generated metadata.

use super::{
    expression_context::{ExpressionContext, ExpressionContextError},
    register_manager::RegisterManager,
};
use crate::generated::{
    generated_traits::{
        get_expression_type, BinaryOperator, ExpressionType, LiteralType, UnaryOperator,
        UpdateOperator,
    },
    unified_instructions::UnifiedInstruction,
};
use anyhow::Result;
use oxc_allocator::Box;
use oxc_ast::{
    ast::{Argument, Expression},
    AstBuilder as OxcAstBuilder,
};
use oxc_span::Span;

/// Error types for instruction-to-expression conversion
#[derive(Debug, thiserror::Error)]
pub enum ConversionError {
    #[error("Unsupported instruction: {0}")]
    UnsupportedInstruction(String),
    #[error("Invalid operand for instruction {instruction}: {message}")]
    InvalidOperand {
        instruction: String,
        message: String,
    },
    #[error("Register {0} not found")]
    RegisterNotFound(u8),
    #[error("Expression context error: {0}")]
    ContextError(#[from] ExpressionContextError),
    #[error("Operand extraction failed: {0}")]
    OperandExtraction(String),
}

/// Main converter for instructions to expressions
///
/// This converter takes unified Hermes instructions and transforms them into
/// OXC AST expressions using the autogenerated instruction metadata and
/// dispatch tables.
pub struct InstructionToExpressionConverter<'a> {
    /// OXC AST builder
    ast_builder: &'a OxcAstBuilder<'a>,
    /// Register management
    register_manager: RegisterManager,
    /// Expression context
    expression_context: ExpressionContext<'a>,
}

impl<'a> InstructionToExpressionConverter<'a> {
    /// Create a new instruction converter
    pub fn new(
        ast_builder: &'a OxcAstBuilder<'a>,
        expression_context: ExpressionContext<'a>,
    ) -> Self {
        Self {
            ast_builder,
            register_manager: RegisterManager::new(),
            expression_context,
        }
    }

    /// Create with custom register manager
    pub fn with_register_manager(
        ast_builder: &'a OxcAstBuilder<'a>,
        expression_context: ExpressionContext<'a>,
        register_manager: RegisterManager,
    ) -> Self {
        Self {
            ast_builder,
            register_manager,
            expression_context,
        }
    }

    /// Convert a unified instruction to an OXC expression
    ///
    /// This is the main entry point for instruction conversion. It uses the
    /// autogenerated expression metadata to dispatch to the appropriate handler.
    pub fn convert_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        use UnifiedInstruction::*;

        // First check if we have generated metadata for this instruction
        let expr_type = get_expression_type(instruction.name());

        match expr_type {
            ExpressionType::Binary(op) => self.handle_binary_expression(instruction, op),
            ExpressionType::Unary(op) => self.handle_unary_expression(instruction, op),
            ExpressionType::Update(op) => self.handle_update_expression(instruction, op),
            ExpressionType::Literal(lit_type) => {
                self.handle_literal_expression(instruction, lit_type)
            }
            ExpressionType::Other => {
                // Handle operations that aren't in the generated metadata yet
                match instruction {
                    // Variable operations
                    Mov { .. } | MovLong { .. } => self.handle_mov_instruction(instruction),
                    LoadParam { .. } | LoadParamLong { .. } => {
                        self.handle_load_param_instruction(instruction)
                    }
                    GetEnvironment { .. } => self.handle_get_environment_instruction(instruction),
                    LoadFromEnvironment { .. } | LoadFromEnvironmentL { .. } => {
                        self.handle_load_from_environment_instruction(instruction)
                    }
                    StoreToEnvironment { .. } | StoreToEnvironmentL { .. } => {
                        self.handle_store_to_environment_instruction(instruction)
                    }

                    // Member expression operations
                    GetByVal { .. } => self.handle_get_by_val_instruction(instruction),
                    PutByVal { .. } => self.handle_put_by_val_instruction(instruction),
                    GetById { .. } | GetByIdShort { .. } | GetByIdLong { .. } => {
                        self.handle_get_by_id_instruction(instruction)
                    }
                    PutById { .. } | PutByIdLong { .. } => {
                        self.handle_put_by_id_instruction(instruction)
                    }
                    TryGetById { .. } | TryGetByIdLong { .. } => {
                        self.handle_try_get_by_id_instruction(instruction)
                    }
                    TryPutById { .. } | TryPutByIdLong { .. } => {
                        self.handle_try_put_by_id_instruction(instruction)
                    }
                    DelByVal { .. } => self.handle_del_by_val_instruction(instruction),
                    DelById { .. } | DelByIdLong { .. } => {
                        self.handle_del_by_id_instruction(instruction)
                    }

                    // Call expression operations
                    Call { .. } | CallLong { .. } => self.handle_call_instruction(instruction),
                    Call1 { .. } | Call2 { .. } | Call3 { .. } | Call4 { .. } => {
                        self.handle_call_fixed_instruction(instruction)
                    }
                    CallDirect { .. } | CallDirectLongIndex { .. } => {
                        self.handle_call_direct_instruction(instruction)
                    }
                    Construct { .. } | ConstructLong { .. } => {
                        self.handle_construct_instruction(instruction)
                    }
                    CallBuiltin { .. } | CallBuiltinLong { .. } => {
                        self.handle_call_builtin_instruction(instruction)
                    }

                    // Object/Array literal operations
                    NewObject { .. } => self.handle_new_object_instruction(instruction),
                    NewObjectWithParent { .. } => {
                        self.handle_new_object_with_parent_instruction(instruction)
                    }
                    NewObjectWithBuffer { .. } | NewObjectWithBufferLong { .. } => {
                        self.handle_new_object_with_buffer_instruction(instruction)
                    }
                    NewArray { .. } => self.handle_new_array_instruction(instruction),
                    NewArrayWithBuffer { .. } | NewArrayWithBufferLong { .. } => {
                        self.handle_new_array_with_buffer_instruction(instruction)
                    }
                    PutOwnByIndex { .. } | PutOwnByIndexL { .. } => {
                        self.handle_put_own_by_index_instruction(instruction)
                    }

                    // Control flow operations that can be converted to conditional expressions
                    // Note: These are typically used in combination with other instructions
                    // to form conditional expressions in certain patterns
                    JmpTrue { .. } | JmpTrueLong { .. } => {
                        self.handle_conditional_jump_instruction(instruction)
                    }
                    JmpFalse { .. } | JmpFalseLong { .. } => {
                        self.handle_conditional_jump_instruction(instruction)
                    }
                    JmpUndefined { .. } | JmpUndefinedLong { .. } => {
                        self.handle_conditional_jump_instruction(instruction)
                    }

                    _ => Err(ConversionError::UnsupportedInstruction(
                        instruction.name().to_string(),
                    )),
                }
            }
        }
    }

    /// Handle binary expressions (arithmetic, comparison, logical)
    fn handle_binary_expression(
        &mut self,
        instruction: &UnifiedInstruction,
        op: BinaryOperator,
    ) -> Result<Expression<'a>, ConversionError> {
        // Convert our internal BinaryOperator to OXC's BinaryOperator
        let oxc_op = match op {
            BinaryOperator::Equality => oxc_ast::ast::BinaryOperator::Equality,
            BinaryOperator::Inequality => oxc_ast::ast::BinaryOperator::Inequality,
            BinaryOperator::StrictEquality => oxc_ast::ast::BinaryOperator::StrictEquality,
            BinaryOperator::StrictInequality => oxc_ast::ast::BinaryOperator::StrictInequality,
            BinaryOperator::LessThan => oxc_ast::ast::BinaryOperator::LessThan,
            BinaryOperator::LessEqualThan => oxc_ast::ast::BinaryOperator::LessEqualThan,
            BinaryOperator::GreaterThan => oxc_ast::ast::BinaryOperator::GreaterThan,
            BinaryOperator::GreaterEqualThan => oxc_ast::ast::BinaryOperator::GreaterEqualThan,
            BinaryOperator::Addition => oxc_ast::ast::BinaryOperator::Addition,
            BinaryOperator::Subtraction => oxc_ast::ast::BinaryOperator::Subtraction,
            BinaryOperator::Multiplication => oxc_ast::ast::BinaryOperator::Multiplication,
            BinaryOperator::Division => oxc_ast::ast::BinaryOperator::Division,
            BinaryOperator::Remainder => oxc_ast::ast::BinaryOperator::Remainder,
            BinaryOperator::ShiftLeft => oxc_ast::ast::BinaryOperator::ShiftLeft,
            BinaryOperator::ShiftRight => oxc_ast::ast::BinaryOperator::ShiftRight,
            BinaryOperator::ShiftRightZeroFill => oxc_ast::ast::BinaryOperator::ShiftRightZeroFill,
            BinaryOperator::BitwiseOR => oxc_ast::ast::BinaryOperator::BitwiseOR,
            BinaryOperator::BitwiseXOR => oxc_ast::ast::BinaryOperator::BitwiseXOR,
            BinaryOperator::BitwiseAnd => oxc_ast::ast::BinaryOperator::BitwiseAnd,
            BinaryOperator::In => oxc_ast::ast::BinaryOperator::In,
            BinaryOperator::Instanceof => oxc_ast::ast::BinaryOperator::Instanceof,
        };

        // Extract operands from instruction
        let (left_expr, right_expr) = self.extract_binary_operands(instruction)?;

        let span = Span::default();
        Ok(self
            .ast_builder
            .expression_binary(span, left_expr, oxc_op, right_expr))
    }

    /// Handle unary expressions (!x, -x, typeof x)
    fn handle_unary_expression(
        &mut self,
        instruction: &UnifiedInstruction,
        op: UnaryOperator,
    ) -> Result<Expression<'a>, ConversionError> {
        let oxc_op = match op {
            UnaryOperator::UnaryNegation => oxc_ast::ast::UnaryOperator::UnaryNegation,
            UnaryOperator::LogicalNot => oxc_ast::ast::UnaryOperator::LogicalNot,
            UnaryOperator::BitwiseNot => oxc_ast::ast::UnaryOperator::BitwiseNot,
            UnaryOperator::Typeof => oxc_ast::ast::UnaryOperator::Typeof,
        };

        let operand = self.extract_unary_operand(instruction)?;

        let span = Span::default();
        Ok(self.ast_builder.expression_unary(span, oxc_op, operand))
    }

    /// Handle update expressions (++x, --x)
    fn handle_update_expression(
        &mut self,
        instruction: &UnifiedInstruction,
        op: UpdateOperator,
    ) -> Result<Expression<'a>, ConversionError> {
        use UnifiedInstruction::*;
        let oxc_op = match op {
            UpdateOperator::Increment => oxc_ast::ast::UpdateOperator::Increment,
            UpdateOperator::Decrement => oxc_ast::ast::UpdateOperator::Decrement,
        };

        let span = Span::default();

        // Extract operand register from update instruction
        let operand_reg = match instruction {
            Inc { operand_1, .. } => *operand_1,
            Dec { operand_1, .. } => *operand_1,
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected Inc or Dec instruction for update expression".to_string(),
                });
            }
        };

        // Track register usage
        self.register_manager
            .track_usage(operand_reg, self.expression_context.current_pc());

        // Get variable name for operand
        let operand_name = self.register_manager.get_variable_name(operand_reg);

        // Allocate string in arena
        let target_atom = self.ast_builder.allocator.alloc_str(&operand_name);

        // Create assignment target for update expression
        let target = self
            .ast_builder
            .simple_assignment_target_assignment_target_identifier(span, target_atom);

        // Assume prefix for now - could be enhanced to detect prefix vs postfix
        Ok(self
            .ast_builder
            .expression_update(span, oxc_op, true, target))
    }

    /// Handle literal expressions (constants)
    fn handle_literal_expression(
        &mut self,
        instruction: &UnifiedInstruction,
        lit_type: LiteralType,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        match lit_type {
            LiteralType::Numeric => self.extract_numeric_literal(instruction),
            LiteralType::String => self.extract_string_literal(instruction),
            LiteralType::BigInt => self.extract_bigint_literal(instruction),
            LiteralType::Boolean => self.extract_boolean_literal(instruction),
            LiteralType::Null => Ok(self.ast_builder.expression_null_literal(span)),
            LiteralType::Undefined => {
                // Undefined is typically represented as an identifier reference
                Ok(self.ast_builder.expression_identifier(span, "undefined"))
            }
            LiteralType::Empty => {
                // Empty string literal
                Ok(self.ast_builder.expression_string_literal(span, "", None))
            }
        }
    }

    // ===== Operand Extraction Methods =====

    /// Extract operands for binary expressions
    fn extract_binary_operands(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<(Expression<'a>, Expression<'a>), ConversionError> {
        use UnifiedInstruction::*;
        let span = Span::default();

        // Extract left and right operand registers based on instruction type
        let (left_reg, right_reg) = match instruction {
            // Arithmetic operations: dest = left op right
            Add { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            Sub { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            Mul { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            Div { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            Mod { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            
            // Arithmetic with immediate values
            AddN { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            SubN { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            MulN { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            DivN { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            
            // 32-bit arithmetic
            Add32 { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            Sub32 { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            Mul32 { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            Divi32 { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            Divu32 { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            
            // Bitwise operations
            BitOr { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            BitAnd { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            BitXor { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            LShift { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            RShift { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            URshift { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            
            // Comparison operations
            Less { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            LessEq { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            Greater { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            GreaterEq { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            Eq { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            Neq { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            StrictEq { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            StrictNeq { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            InstanceOf { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            IsIn { operand_1, operand_2, .. } => (*operand_1, *operand_2),
            
            // Special case: AddEmptyString converts value to string by adding empty string
            AddEmptyString { operand_1, .. } => {
                // Create a special case where right operand is empty string literal
                let left_reg = *operand_1;
                
                // Track register usage for left operand
                self.register_manager
                    .track_usage(left_reg, self.expression_context.current_pc());

                // Get variable name for left operand
                let left_name = self.register_manager.get_variable_name(left_reg);
                let left_atom = self.ast_builder.allocator.alloc_str(&left_name);
                let left_expr = self.ast_builder.expression_identifier(span, left_atom);

                // Create empty string literal for right operand
                let right_expr = self.ast_builder.expression_string_literal(span, "", None);

                return Ok((left_expr, right_expr));
            }
            
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Instruction does not support binary operand extraction".to_string(),
                });
            }
        };

        // Track register usage
        self.register_manager
            .track_usage(left_reg, self.expression_context.current_pc());
        self.register_manager
            .track_usage(right_reg, self.expression_context.current_pc());

        // Get variable names for operands
        let left_name = self.register_manager.get_variable_name(left_reg);
        let right_name = self.register_manager.get_variable_name(right_reg);

        // Allocate strings in arena
        let left_atom = self.ast_builder.allocator.alloc_str(&left_name);
        let right_atom = self.ast_builder.allocator.alloc_str(&right_name);

        // Create identifier expressions
        let left_expr = self.ast_builder.expression_identifier(span, left_atom);
        let right_expr = self.ast_builder.expression_identifier(span, right_atom);

        Ok((left_expr, right_expr))
    }

    /// Extract operand for unary expressions
    fn extract_unary_operand(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        use UnifiedInstruction::*;
        let span = Span::default();

        // Extract operand register based on instruction type
        let operand_reg = match instruction {
            // Unary arithmetic operations
            Negate { operand_1, .. } => *operand_1,
            
            // Logical operations
            Not { operand_1, .. } => *operand_1,
            
            // Bitwise operations
            BitNot { operand_1, .. } => *operand_1,
            
            // Type operations
            TypeOf { operand_1, .. } => *operand_1,
            ToNumber { operand_1, .. } => *operand_1,
            ToNumeric { operand_1, .. } => *operand_1,
            ToInt32 { operand_1, .. } => *operand_1,
            
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Instruction does not support unary operand extraction".to_string(),
                });
            }
        };

        // Track register usage
        self.register_manager
            .track_usage(operand_reg, self.expression_context.current_pc());

        // Get variable name for operand
        let operand_name = self.register_manager.get_variable_name(operand_reg);

        // Allocate string in arena
        let operand_atom = self.ast_builder.allocator.alloc_str(&operand_name);

        // Create identifier expression
        Ok(self.ast_builder.expression_identifier(span, operand_atom))
    }

    /// Extract numeric literal value from LoadConst instructions
    fn extract_numeric_literal(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        let value = match instruction {
            UnifiedInstruction::LoadConstUInt8 { operand_1, .. } => *operand_1 as f64,
            UnifiedInstruction::LoadConstInt { operand_1, .. } => *operand_1 as f64,
            UnifiedInstruction::LoadConstZero { .. } => 0.0,
            UnifiedInstruction::LoadConstDouble { operand_1, .. } => *operand_1,
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Not a numeric constant instruction".to_string(),
                });
            }
        };

        // Allocate the raw string in the arena to get proper lifetime
        let raw_str = self.ast_builder.allocator.alloc_str(&value.to_string());
        Ok(self.ast_builder.expression_numeric_literal(
            span,
            value,
            Some(raw_str.into()),
            oxc_ast::ast::NumberBase::Decimal,
        ))
    }

    /// Extract string literal value from LoadConstString instructions
    fn extract_string_literal(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        let string_value = match instruction {
            UnifiedInstruction::LoadConstString { operand_1, .. } => {
                self.expression_context.lookup_string(*operand_1 as u32)?
            }
            UnifiedInstruction::LoadConstStringLongIndex { operand_1, .. } => {
                self.expression_context.lookup_string(*operand_1 as u32)?
            }
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Not a string constant instruction".to_string(),
                });
            }
        };

        // Allocate the string in the arena to get proper lifetime
        let allocated_str = self.ast_builder.allocator.alloc_str(&string_value);
        Ok(self
            .ast_builder
            .expression_string_literal(span, allocated_str, None))
    }

    /// Extract BigInt literal value from LoadConstBigInt instructions
    fn extract_bigint_literal(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        let bigint_value = match instruction {
            UnifiedInstruction::LoadConstBigInt { operand_1, .. } => {
                self.expression_context.lookup_bigint(*operand_1 as u32)?
            }
            UnifiedInstruction::LoadConstBigIntLongIndex { operand_1, .. } => {
                self.expression_context.lookup_bigint(*operand_1 as u32)?
            }
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Not a BigInt constant instruction".to_string(),
                });
            }
        };

        // Allocate the bigint string in the arena to get proper lifetime
        let allocated_bigint = self.ast_builder.allocator.alloc_str(&bigint_value);
        Ok(self.ast_builder.expression_big_int_literal(
            span,
            allocated_bigint,
            Some(allocated_bigint.into()),
            oxc_ast::ast::BigintBase::Decimal,
        ))
    }

    /// Extract boolean literal value from LoadConst instructions
    fn extract_boolean_literal(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        let value = match instruction {
            UnifiedInstruction::LoadConstTrue { .. } => true,
            UnifiedInstruction::LoadConstFalse { .. } => false,
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Not a boolean constant instruction".to_string(),
                });
            }
        };

        Ok(self.ast_builder.expression_boolean_literal(span, value))
    }

    // ===== Public API Methods =====

    /// Get mutable reference to register manager
    pub fn register_manager_mut(&mut self) -> &mut RegisterManager {
        &mut self.register_manager
    }

    /// Get reference to register manager
    pub fn register_manager(&self) -> &RegisterManager {
        &self.register_manager
    }

    /// Get reference to expression context
    pub fn expression_context(&self) -> &ExpressionContext<'a> {
        &self.expression_context
    }

    /// Get mutable reference to expression context
    pub fn expression_context_mut(&mut self) -> &mut ExpressionContext<'a> {
        &mut self.expression_context
    }

    /// Update the current PC in the expression context
    pub fn set_current_pc(&mut self, pc: u32) {
        self.expression_context.set_pc(pc);
    }

    /// Update the current block in the expression context
    pub fn set_current_block(&mut self, block_id: u32) {
        self.expression_context.set_block(block_id);
    }

    /// Reset converter state (useful for function boundaries)
    pub fn reset(&mut self) {
        self.register_manager.reset();
        self.expression_context.reset();
    }

    /// Get conversion statistics
    pub fn get_stats(&self) -> ConversionStats {
        let register_stats = self.register_manager.get_stats();

        ConversionStats {
            register_stats,
            current_pc: self.expression_context.current_pc(),
            current_block: self.expression_context.current_block(),
            function_index: self.expression_context.function_index(),
            has_hbc_context: self.expression_context.has_hbc_file(),
        }
    }

    // ===== Variable Operation Handlers =====

    /// Handle Mov instruction (register-to-register move)
    fn handle_mov_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract source register from instruction
        let source_reg = match instruction {
            UnifiedInstruction::Mov { operand_1, .. } => *operand_1,
            UnifiedInstruction::MovLong { operand_1, .. } => *operand_1 as u8,
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected Mov or MovLong instruction".to_string(),
                })
            }
        };

        // Track register usage
        self.register_manager
            .track_usage(source_reg, self.expression_context.current_pc());

        // Get or create variable name for the source register
        let var_name = self.register_manager.get_variable_name(source_reg);

        // Allocate the string in the arena
        let var_name_atom = self.ast_builder.allocator.alloc_str(&var_name);

        // Create identifier expression
        Ok(self.ast_builder.expression_identifier(span, var_name_atom))
    }

    /// Handle LoadParam instruction (load function parameter)
    fn handle_load_param_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract parameter index
        let param_index = match instruction {
            UnifiedInstruction::LoadParam { operand_1, .. } => *operand_1,
            UnifiedInstruction::LoadParamLong { operand_1, .. } => *operand_1 as u8,
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected LoadParam or LoadParamLong instruction".to_string(),
                })
            }
        };

        // Mark the destination register as a parameter
        if let UnifiedInstruction::LoadParam { operand_0, .. }
        | UnifiedInstruction::LoadParamLong { operand_0, .. } = instruction
        {
            self.register_manager
                .mark_as_parameter(*operand_0 as u8, self.expression_context.current_pc());
        }

        // Create parameter name (e.g., param0, param1, etc.)
        let param_name = format!("param{}", param_index);

        // Allocate the string in the arena
        let param_name_atom = self.ast_builder.allocator.alloc_str(&param_name);

        // Create identifier expression
        Ok(self
            .ast_builder
            .expression_identifier(span, param_name_atom))
    }

    /// Handle GetEnvironment instruction (access closure environment)
    fn handle_get_environment_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract environment index
        let env_index = match instruction {
            UnifiedInstruction::GetEnvironment { operand_1, .. } => *operand_1,
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected GetEnvironment instruction".to_string(),
                })
            }
        };

        // Create environment access expression
        // This typically represents accessing the closure's environment
        let env_name = format!("__env{}", env_index);
        let env_name_atom = self.ast_builder.allocator.alloc_str(&env_name);
        Ok(self.ast_builder.expression_identifier(span, env_name_atom))
    }

    /// Handle LoadFromEnvironment instruction (load variable from closure)
    fn handle_load_from_environment_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract environment register and slot index
        let (_env_reg, slot_index) = match instruction {
            UnifiedInstruction::LoadFromEnvironment {
                operand_1,
                operand_2,
                ..
            } => (*operand_1, *operand_2 as u32),
            UnifiedInstruction::LoadFromEnvironmentL {
                operand_1,
                operand_2,
                ..
            } => (*operand_1, *operand_2 as u32),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected LoadFromEnvironment instruction".to_string(),
                })
            }
        };

        // Create closure variable access
        // TODO (AST-03): Map closure environment slot indices to actual variable names
        // Priority: Medium - Required for meaningful variable names in closure decompilation
        let var_name = format!("__closure_var_{}", slot_index);
        let var_name_atom = self.ast_builder.allocator.alloc_str(&var_name);
        Ok(self.ast_builder.expression_identifier(span, var_name_atom))
    }

    /// Handle StoreToEnvironment instruction (store variable to closure)
    fn handle_store_to_environment_instruction(
        &mut self,
        _instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        // StoreToEnvironment is a statement, not an expression
        // TODO (AST-02): Implement statement-level handling for StoreToEnvironment
        // Priority: Medium - These operations should be handled in statement conversion
        Err(ConversionError::UnsupportedInstruction(
            "StoreToEnvironment requires statement-level handling".to_string(),
        ))
    }

    // ===== Member Expression Handlers =====

    /// Handle GetByVal instruction (obj[key] dynamic property access)
    fn handle_get_by_val_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract object and property registers
        let (obj_reg, prop_reg) = match instruction {
            UnifiedInstruction::GetByVal {
                operand_1,
                operand_2,
                ..
            } => (*operand_1, *operand_2),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected GetByVal instruction".to_string(),
                })
            }
        };

        // Track register usage
        self.register_manager
            .track_usage(obj_reg, self.expression_context.current_pc());
        self.register_manager
            .track_usage(prop_reg, self.expression_context.current_pc());

        // Get variable names for object and property
        let obj_name = self.register_manager.get_variable_name(obj_reg);
        let prop_name = self.register_manager.get_variable_name(prop_reg);

        // Allocate strings in arena
        let obj_atom = self.ast_builder.allocator.alloc_str(&obj_name);
        let prop_atom = self.ast_builder.allocator.alloc_str(&prop_name);

        // Create object and property expressions
        let object_expr = self.ast_builder.expression_identifier(span, obj_atom);
        let property_expr = self.ast_builder.expression_identifier(span, prop_atom);

        // Create computed member expression (obj[key])
        let computed_member = self.ast_builder.alloc_computed_member_expression(
            span,
            object_expr,
            property_expr,
            false,
        );
        Ok(Expression::ComputedMemberExpression(computed_member))
    }

    /// Handle PutByVal instruction (obj[key] = value assignment)
    fn handle_put_by_val_instruction(
        &mut self,
        _instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        // PutByVal is an assignment statement, not an expression
        // TODO (AST-02): Implement statement-level handling for PutByVal operations
        // Priority: Medium - Assignment operations require statement-level conversion
        Err(ConversionError::UnsupportedInstruction(
            "PutByVal requires statement-level handling".to_string(),
        ))
    }

    /// Handle GetById instruction (obj.prop static property access)
    fn handle_get_by_id_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract object register and property string ID
        let (obj_reg, prop_id) = match instruction {
            UnifiedInstruction::GetById {
                operand_1,
                operand_3,
                ..
            } => (*operand_1, *operand_3 as u32),
            UnifiedInstruction::GetByIdShort {
                operand_1,
                operand_3,
                ..
            } => (*operand_1, *operand_3 as u32),
            UnifiedInstruction::GetByIdLong {
                operand_1,
                operand_3,
                ..
            } => (*operand_1, *operand_3),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected GetById instruction".to_string(),
                })
            }
        };

        // Track register usage
        self.register_manager
            .track_usage(obj_reg, self.expression_context.current_pc());

        // Get object variable name
        let obj_name = self.register_manager.get_variable_name(obj_reg);
        let obj_atom = self.ast_builder.allocator.alloc_str(&obj_name);

        // Get property name from string table
        let prop_name = self.expression_context.lookup_string(prop_id)?;
        let prop_atom = self.ast_builder.allocator.alloc_str(&prop_name);

        // Create object expression and property identifier name
        let object_expr = self.ast_builder.expression_identifier(span, obj_atom);
        let property_name = self.ast_builder.identifier_name(span, prop_atom);

        // Create static member expression (obj.prop)
        let static_member = self.ast_builder.alloc_static_member_expression(
            span,
            object_expr,
            property_name,
            false,
        );
        Ok(Expression::StaticMemberExpression(static_member))
    }

    /// Handle PutById instruction (obj.prop = value assignment)
    fn handle_put_by_id_instruction(
        &mut self,
        _instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        // PutById is an assignment statement, not an expression
        // TODO (AST-02): Implement statement-level handling for PutById operations
        // Priority: Medium - Property assignment requires statement-level conversion
        Err(ConversionError::UnsupportedInstruction(
            "PutById requires statement-level handling".to_string(),
        ))
    }

    /// Handle TryGetById instruction (obj.prop with exception handling)
    fn handle_try_get_by_id_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        // TryGetById behaves the same as GetById for expression purposes
        // The "try" aspect is handled at a higher level for exception handling
        self.handle_get_by_id_instruction(instruction)
    }

    /// Handle TryPutById instruction (obj.prop = value with exception handling)
    fn handle_try_put_by_id_instruction(
        &mut self,
        _instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        // TryPutById is an assignment statement, not an expression
        Err(ConversionError::UnsupportedInstruction(
            "TryPutById requires statement-level handling".to_string(),
        ))
    }

    /// Handle DelByVal instruction (delete obj[key])
    fn handle_del_by_val_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract object and property registers
        let (obj_reg, prop_reg) = match instruction {
            UnifiedInstruction::DelByVal {
                operand_1,
                operand_2,
                ..
            } => (*operand_1, *operand_2),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected DelByVal instruction".to_string(),
                })
            }
        };

        // Track register usage
        self.register_manager
            .track_usage(obj_reg, self.expression_context.current_pc());
        self.register_manager
            .track_usage(prop_reg, self.expression_context.current_pc());

        // Get variable names
        let obj_name = self.register_manager.get_variable_name(obj_reg);
        let prop_name = self.register_manager.get_variable_name(prop_reg);

        // Allocate strings in arena
        let obj_atom = self.ast_builder.allocator.alloc_str(&obj_name);
        let prop_atom = self.ast_builder.allocator.alloc_str(&prop_name);

        // Create computed member expression for the delete target
        let object_expr = self.ast_builder.expression_identifier(span, obj_atom);
        let property_expr = self.ast_builder.expression_identifier(span, prop_atom);
        let computed_member = self.ast_builder.alloc_computed_member_expression(
            span,
            object_expr,
            property_expr,
            false,
        );
        let member_expr = Expression::ComputedMemberExpression(computed_member);

        // Create delete unary expression
        Ok(self.ast_builder.expression_unary(
            span,
            oxc_ast::ast::UnaryOperator::Delete,
            member_expr,
        ))
    }

    /// Handle DelById instruction (delete obj.prop)
    fn handle_del_by_id_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract object register and property string ID
        let (obj_reg, prop_id) = match instruction {
            UnifiedInstruction::DelById {
                operand_1,
                operand_2,
                ..
            } => (*operand_1, *operand_2 as u32),
            UnifiedInstruction::DelByIdLong {
                operand_1,
                operand_2,
                ..
            } => (*operand_1, *operand_2),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected DelById instruction".to_string(),
                })
            }
        };

        // Track register usage
        self.register_manager
            .track_usage(obj_reg, self.expression_context.current_pc());

        // Get object variable name
        let obj_name = self.register_manager.get_variable_name(obj_reg);
        let obj_atom = self.ast_builder.allocator.alloc_str(&obj_name);

        // Get property name from string table
        let prop_name = self.expression_context.lookup_string(prop_id)?;
        let prop_atom = self.ast_builder.allocator.alloc_str(&prop_name);

        // Create static member expression for the delete target
        let object_expr = self.ast_builder.expression_identifier(span, obj_atom);
        let property_name = self.ast_builder.identifier_name(span, prop_atom);
        let static_member = self.ast_builder.alloc_static_member_expression(
            span,
            object_expr,
            property_name,
            false,
        );
        let member_expr = Expression::StaticMemberExpression(static_member);

        // Create delete unary expression
        Ok(self.ast_builder.expression_unary(
            span,
            oxc_ast::ast::UnaryOperator::Delete,
            member_expr,
        ))
    }

    // ===== Call Expression Handlers =====

    /// Handle Call instruction (function(args...))
    fn handle_call_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract function register and argument count
        let (func_reg, arg_count) = match instruction {
            UnifiedInstruction::Call {
                operand_0: func_reg,
                operand_1: arg_count,
                ..
            } => (*func_reg, *arg_count as usize),
            UnifiedInstruction::CallLong {
                operand_0: func_reg,
                operand_1: arg_count,
                ..
            } => (*func_reg, *arg_count as usize),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected Call instruction".to_string(),
                })
            }
        };

        // Track function register usage
        self.register_manager
            .track_usage(func_reg, self.expression_context.current_pc());

        // Get function variable name
        let func_name = self.register_manager.get_variable_name(func_reg);
        let func_atom = self.ast_builder.allocator.alloc_str(&func_name);

        // Create function expression
        let callee = self.ast_builder.expression_identifier(span, func_atom);

        // Create argument expressions
        let mut arguments = Vec::new();
        for i in 0..arg_count {
            let arg_reg = func_reg + 1 + i as u8; // Arguments are in consecutive registers after function
            self.register_manager
                .track_usage(arg_reg, self.expression_context.current_pc());

            let arg_name = self.register_manager.get_variable_name(arg_reg);
            let arg_atom = self.ast_builder.allocator.alloc_str(&arg_name);
            let arg_expr = self.ast_builder.expression_identifier(span, arg_atom);
            arguments.push(Argument::from(arg_expr));
        }

        // Create call expression
        let arguments = self.ast_builder.vec_from_iter(arguments);
        let type_args: Option<Box<'a, oxc_ast::ast::TSTypeParameterInstantiation<'a>>> = None;
        Ok(self
            .ast_builder
            .expression_call(span, callee, type_args, arguments, false))
    }

    /// Handle Call with fixed argument count (Call1, Call2, Call3, Call4)
    fn handle_call_fixed_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract function register and determine argument count from instruction name
        let (func_reg, arg_count) = match instruction {
            UnifiedInstruction::Call1 {
                operand_0: func_reg,
                ..
            } => (*func_reg, 1),
            UnifiedInstruction::Call2 {
                operand_0: func_reg,
                ..
            } => (*func_reg, 2),
            UnifiedInstruction::Call3 {
                operand_0: func_reg,
                ..
            } => (*func_reg, 3),
            UnifiedInstruction::Call4 {
                operand_0: func_reg,
                ..
            } => (*func_reg, 4),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected CallN instruction".to_string(),
                })
            }
        };

        // Track function register usage
        self.register_manager
            .track_usage(func_reg, self.expression_context.current_pc());

        // Get function variable name
        let func_name = self.register_manager.get_variable_name(func_reg);
        let func_atom = self.ast_builder.allocator.alloc_str(&func_name);

        // Create function expression
        let callee = self.ast_builder.expression_identifier(span, func_atom);

        // Create argument expressions
        let mut arguments = Vec::new();
        for i in 0..arg_count {
            let arg_reg = func_reg + 1 + i as u8; // Arguments are in consecutive registers after function
            self.register_manager
                .track_usage(arg_reg, self.expression_context.current_pc());

            let arg_name = self.register_manager.get_variable_name(arg_reg);
            let arg_atom = self.ast_builder.allocator.alloc_str(&arg_name);
            let arg_expr = self.ast_builder.expression_identifier(span, arg_atom);
            arguments.push(Argument::from(arg_expr));
        }

        // Create call expression
        let arguments = self.ast_builder.vec_from_iter(arguments);
        let type_args: Option<Box<'a, oxc_ast::ast::TSTypeParameterInstantiation<'a>>> = None;
        Ok(self
            .ast_builder
            .expression_call(span, callee, type_args, arguments, false))
    }

    /// Handle CallDirect instruction (direct function call)
    fn handle_call_direct_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract function index and argument count
        let (func_index, arg_count) = match instruction {
            UnifiedInstruction::CallDirect {
                operand_2: func_index,
                operand_1: arg_count,
                ..
            } => (*func_index as u32, *arg_count as usize),
            UnifiedInstruction::CallDirectLongIndex {
                operand_2: func_index,
                operand_1: arg_count,
                ..
            } => (*func_index, *arg_count as usize),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected CallDirect instruction".to_string(),
                })
            }
        };

        // Create function name based on function index
        let func_name = format!("func_{}", func_index);
        let func_atom = self.ast_builder.allocator.alloc_str(&func_name);

        // Create function expression
        let callee = self.ast_builder.expression_identifier(span, func_atom);

        // Create argument expressions
        let mut arguments = Vec::new();
        for i in 0..arg_count {
            // For direct calls, arguments start from register 0
            let arg_reg = i as u8;
            self.register_manager
                .track_usage(arg_reg, self.expression_context.current_pc());

            let arg_name = self.register_manager.get_variable_name(arg_reg);
            let arg_atom = self.ast_builder.allocator.alloc_str(&arg_name);
            let arg_expr = self.ast_builder.expression_identifier(span, arg_atom);
            arguments.push(Argument::from(arg_expr));
        }

        // Create call expression
        let arguments = self.ast_builder.vec_from_iter(arguments);
        let type_args: Option<Box<'a, oxc_ast::ast::TSTypeParameterInstantiation<'a>>> = None;
        Ok(self
            .ast_builder
            .expression_call(span, callee, type_args, arguments, false))
    }

    /// Handle Construct instruction (new Constructor(args...))
    fn handle_construct_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract constructor register and argument count
        let (ctor_reg, arg_count) = match instruction {
            UnifiedInstruction::Construct {
                operand_0: ctor_reg,
                operand_1: arg_count,
                ..
            } => (*ctor_reg, *arg_count as usize),
            UnifiedInstruction::ConstructLong {
                operand_0: ctor_reg,
                operand_1: arg_count,
                ..
            } => (*ctor_reg, *arg_count as usize),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected Construct instruction".to_string(),
                })
            }
        };

        // Track constructor register usage
        self.register_manager
            .track_usage(ctor_reg, self.expression_context.current_pc());

        // Get constructor variable name
        let ctor_name = self.register_manager.get_variable_name(ctor_reg);
        let ctor_atom = self.ast_builder.allocator.alloc_str(&ctor_name);

        // Create constructor expression
        let callee = self.ast_builder.expression_identifier(span, ctor_atom);

        // Create argument expressions
        let mut arguments = Vec::new();
        for i in 0..arg_count {
            let arg_reg = ctor_reg + 1 + i as u8; // Arguments are in consecutive registers after constructor
            self.register_manager
                .track_usage(arg_reg, self.expression_context.current_pc());

            let arg_name = self.register_manager.get_variable_name(arg_reg);
            let arg_atom = self.ast_builder.allocator.alloc_str(&arg_name);
            let arg_expr = self.ast_builder.expression_identifier(span, arg_atom);
            arguments.push(Argument::from(arg_expr));
        }

        // Create new expression
        let arguments = self.ast_builder.vec_from_iter(arguments);
        let type_args: Option<Box<'a, oxc_ast::ast::TSTypeParameterInstantiation<'a>>> = None;
        Ok(self
            .ast_builder
            .expression_new(span, callee, type_args, arguments))
    }

    /// Handle CallBuiltin instruction (built-in function call)
    fn handle_call_builtin_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract builtin index and argument count
        let (builtin_index, arg_count) = match instruction {
            UnifiedInstruction::CallBuiltin {
                operand_0: builtin_index,
                operand_1: arg_count,
                ..
            } => (*builtin_index as u32, *arg_count as usize),
            UnifiedInstruction::CallBuiltinLong {
                operand_0: builtin_index,
                operand_1: arg_count,
                ..
            } => (*builtin_index as u32, *arg_count as usize),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected CallBuiltin instruction".to_string(),
                })
            }
        };

        // Create builtin function name based on index
        // TODO (AST-09): Implement builtin function name mapping table
        // Priority: Medium - Map builtin indices to actual JavaScript function names
        // e.g., builtin_15 -> Math.abs, builtin_42 -> Array.prototype.push
        let builtin_name = format!("builtin_{}", builtin_index);
        let builtin_atom = self.ast_builder.allocator.alloc_str(&builtin_name);

        // Create builtin function expression
        let callee = self.ast_builder.expression_identifier(span, builtin_atom);

        // Create argument expressions
        let mut arguments = Vec::new();
        for i in 0..arg_count {
            // For builtin calls, arguments start from register 0
            let arg_reg = i as u8;
            self.register_manager
                .track_usage(arg_reg, self.expression_context.current_pc());

            let arg_name = self.register_manager.get_variable_name(arg_reg);
            let arg_atom = self.ast_builder.allocator.alloc_str(&arg_name);
            let arg_expr = self.ast_builder.expression_identifier(span, arg_atom);
            arguments.push(Argument::from(arg_expr));
        }

        // Create call expression
        let arguments = self.ast_builder.vec_from_iter(arguments);
        let type_args: Option<Box<'a, oxc_ast::ast::TSTypeParameterInstantiation<'a>>> = None;
        Ok(self
            .ast_builder
            .expression_call(span, callee, type_args, arguments, false))
    }

    // ===== Object/Array Literal Handlers =====

    /// Handle NewObject instruction (empty object literal {})
    fn handle_new_object_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract destination register
        let _dest_reg = match instruction {
            UnifiedInstruction::NewObject { operand_0 } => *operand_0,
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected NewObject instruction".to_string(),
                })
            }
        };

        // Create empty object expression
        let properties = self.ast_builder.vec();
        Ok(self.ast_builder.expression_object(span, properties))
    }

    /// Handle NewObjectWithParent instruction (object with prototype)
    fn handle_new_object_with_parent_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract registers
        let (_dest_reg, parent_reg) = match instruction {
            UnifiedInstruction::NewObjectWithParent {
                operand_0,
                operand_1,
            } => (*operand_0, *operand_1),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected NewObjectWithParent instruction".to_string(),
                })
            }
        };

        // Track parent register usage
        self.register_manager
            .track_usage(parent_reg, self.expression_context.current_pc());

        // Get parent variable name
        let parent_name = self.register_manager.get_variable_name(parent_reg);
        let parent_atom = self.ast_builder.allocator.alloc_str(&parent_name);

        // Create Object.create(parent) call
        let object_ident = self.ast_builder.expression_identifier(span, "Object");
        let create_name = self.ast_builder.identifier_name(span, "create");
        let create_member =
            self.ast_builder
                .alloc_static_member_expression(span, object_ident, create_name, false);
        let callee = Expression::StaticMemberExpression(create_member);

        let parent_expr = self.ast_builder.expression_identifier(span, parent_atom);
        let arguments = self.ast_builder.vec1(Argument::from(parent_expr));

        let type_args: Option<Box<'a, oxc_ast::ast::TSTypeParameterInstantiation<'a>>> = None;
        Ok(self
            .ast_builder
            .expression_call(span, callee, type_args, arguments, false))
    }

    /// Handle NewObjectWithBuffer instruction (object literal with pre-allocated properties)
    fn handle_new_object_with_buffer_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract buffer indices
        let (key_buffer_index, value_buffer_index) = match instruction {
            UnifiedInstruction::NewObjectWithBuffer {
                operand_2,
                operand_3,
                ..
            } => (*operand_2 as u32, *operand_3 as u32),
            UnifiedInstruction::NewObjectWithBufferLong {
                operand_2,
                operand_3,
                ..
            } => (*operand_2 as u32, *operand_3),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected NewObjectWithBuffer instruction".to_string(),
                })
            }
        };

        // TODO (AST-09): Implement object literal buffer lookup for pre-allocated properties
        // Priority: High - Essential for correct object literal decompilation
        // Should access serialized literal tables from HBC file
        let mut properties = Vec::new();

        // Currently creating placeholder property
        let key_str = format!("prop_{}", key_buffer_index);
        let key_atom = self.ast_builder.allocator.alloc_str(&key_str);
        let key = self
            .ast_builder
            .property_key_static_identifier(span, key_atom);

        let value_str = format!("value_{}", value_buffer_index);
        let value_atom = self.ast_builder.allocator.alloc_str(&value_str);
        let value = self.ast_builder.expression_identifier(span, value_atom);
        let property = self.ast_builder.object_property(
            span,
            oxc_ast::ast::PropertyKind::Init,
            key,
            value,
            false,
            false,
            false,
        );
        properties.push(oxc_ast::ast::ObjectPropertyKind::ObjectProperty(
            self.ast_builder.alloc(property),
        ));

        let properties = self.ast_builder.vec_from_iter(properties);
        Ok(self.ast_builder.expression_object(span, properties))
    }

    /// Handle NewArray instruction (empty array literal [])
    fn handle_new_array_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract size hint (not used for empty array)
        let (_dest_reg, _size_hint) = match instruction {
            UnifiedInstruction::NewArray {
                operand_0,
                operand_1,
            } => (*operand_0, *operand_1),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected NewArray instruction".to_string(),
                })
            }
        };

        // Create empty array expression
        let elements = self.ast_builder.vec();
        Ok(self.ast_builder.expression_array(span, elements))
    }

    /// Handle NewArrayWithBuffer instruction (array literal with pre-allocated elements)
    fn handle_new_array_with_buffer_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        // Extract buffer indices and count
        let (buffer_index, element_count) = match instruction {
            UnifiedInstruction::NewArrayWithBuffer {
                operand_2,
                operand_3,
                ..
            } => (*operand_2 as u32, *operand_3 as usize),
            UnifiedInstruction::NewArrayWithBufferLong {
                operand_2,
                operand_3,
                ..
            } => (*operand_2 as u32, *operand_3 as usize),
            _ => {
                return Err(ConversionError::InvalidOperand {
                    instruction: instruction.name().to_string(),
                    message: "Expected NewArrayWithBuffer instruction".to_string(),
                })
            }
        };

        // TODO (AST-09): Implement array literal buffer lookup for pre-allocated elements
        // Priority: High - Essential for correct array literal decompilation
        // Should access serialized literal tables from HBC file
        let mut elements = Vec::new();
        for i in 0..element_count {
            let element_str = format!("element_{}_{}", buffer_index, i);
            let element_atom = self.ast_builder.allocator.alloc_str(&element_str);
            let element_expr = self.ast_builder.expression_identifier(span, element_atom);
            elements.push(oxc_ast::ast::ArrayExpressionElement::from(element_expr));
        }

        let elements = self.ast_builder.vec_from_iter(elements);
        Ok(self.ast_builder.expression_array(span, elements))
    }

    /// Handle PutOwnByIndex instruction (array element assignment)
    fn handle_put_own_by_index_instruction(
        &mut self,
        _instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        // PutOwnByIndex is a statement-level operation (array[index] = value)
        // It modifies an existing array and doesn't produce an expression
        Err(ConversionError::UnsupportedInstruction(
            "PutOwnByIndex requires statement-level handling".to_string(),
        ))
    }

    // ===== Control Flow Expression Handlers =====

    /// Handle conditional jump instructions that might be part of conditional expressions
    /// 
    /// TODO (AST-16): Implement advanced pattern detection for control flow expressions
    /// Priority: Low - Enhanced decompilation quality
    /// Should analyze instruction sequences to detect ternary operators and complex conditionals
    fn handle_conditional_jump_instruction(
        &mut self,
        instruction: &UnifiedInstruction,
    ) -> Result<Expression<'a>, ConversionError> {
        let span = Span::default();

        use UnifiedInstruction::*;
        
        match instruction {
            JmpTrue { operand_1, .. } | JmpTrueLong { operand_1, .. } => {
                // Track condition register usage
                self.register_manager
                    .track_usage(*operand_1, self.expression_context.current_pc());

                // Get condition variable name
                let condition_name = self.register_manager.get_variable_name(*operand_1);
                let condition_atom = self.ast_builder.allocator.alloc_str(&condition_name);

                // For JmpTrue, we create a logical expression that evaluates the condition
                // TODO (AST-16): Integrate with pattern analysis system for complex conditionals
                // Priority: Low - Part of advanced control flow reconstruction
                let condition_expr = self.ast_builder.expression_identifier(span, condition_atom);
                
                // Create a simple conditional expression: condition || false
                let false_expr = self.ast_builder.expression_boolean_literal(span, false);
                Ok(self.ast_builder.expression_logical(
                    span,
                    condition_expr,
                    oxc_ast::ast::LogicalOperator::Or,
                    false_expr,
                ))
            }

            JmpFalse { operand_1, .. } | JmpFalseLong { operand_1, .. } => {
                // Track condition register usage
                self.register_manager
                    .track_usage(*operand_1, self.expression_context.current_pc());

                // Get condition variable name
                let condition_name = self.register_manager.get_variable_name(*operand_1);
                let condition_atom = self.ast_builder.allocator.alloc_str(&condition_name);

                // For JmpFalse, we create the negated condition
                let condition_expr = self.ast_builder.expression_identifier(span, condition_atom);
                
                // Create negated condition: !condition
                Ok(self.ast_builder.expression_unary(
                    span,
                    oxc_ast::ast::UnaryOperator::LogicalNot,
                    condition_expr,
                ))
            }

            JmpUndefined { operand_1, .. } | JmpUndefinedLong { operand_1, .. } => {
                // Track register usage
                self.register_manager
                    .track_usage(*operand_1, self.expression_context.current_pc());

                // Get variable name
                let var_name = self.register_manager.get_variable_name(*operand_1);
                let var_atom = self.ast_builder.allocator.alloc_str(&var_name);

                // Create undefined check: variable === undefined
                let var_expr = self.ast_builder.expression_identifier(span, var_atom);
                let undefined_expr = self.ast_builder.expression_identifier(span, "undefined");
                
                Ok(self.ast_builder.expression_binary(
                    span,
                    var_expr,
                    oxc_ast::ast::BinaryOperator::StrictEquality,
                    undefined_expr,
                ))
            }

            _ => Err(ConversionError::InvalidOperand {
                instruction: instruction.name().to_string(),
                message: "Expected conditional jump instruction".to_string(),
            }),
        }
    }

    /// Create a conditional expression (ternary operator: condition ? consequent : alternate)
    /// 
    /// This is a utility method that can be used by higher-level analysis to create
    /// conditional expressions when patterns are detected in instruction sequences.
    pub fn create_conditional_expression(
        &mut self,
        condition: Expression<'a>,
        consequent: Expression<'a>,
        alternate: Expression<'a>,
    ) -> Expression<'a> {
        let span = Span::default();
        self.ast_builder
            .expression_conditional(span, condition, consequent, alternate)
    }

    /// Create a logical expression (&&, ||)
    /// 
    /// This can be used for short-circuit evaluation patterns often found in
    /// conditional logic compiled from JavaScript.
    pub fn create_logical_expression(
        &mut self,
        left: Expression<'a>,
        operator: LogicalOperator,
        right: Expression<'a>,
    ) -> Expression<'a> {
        let span = Span::default();
        let oxc_op = match operator {
            LogicalOperator::And => oxc_ast::ast::LogicalOperator::And,
            LogicalOperator::Or => oxc_ast::ast::LogicalOperator::Or,
            LogicalOperator::Coalesce => oxc_ast::ast::LogicalOperator::Coalesce,
        };
        self.ast_builder.expression_logical(span, left, oxc_op, right)
    }
}

/// Logical operators for creating logical expressions
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LogicalOperator {
    And,      // &&
    Or,       // ||
    Coalesce, // ??
}

/// Statistics about the conversion process
#[derive(Debug, Clone)]
pub struct ConversionStats {
    pub register_stats: crate::ast::register_manager::RegisterStats,
    pub current_pc: u32,
    pub current_block: Option<u32>,
    pub function_index: Option<u32>,
    pub has_hbc_context: bool,
}

#[cfg(test)]
mod tests {
    use super::*;
    use oxc_allocator::Allocator;

    #[test]
    fn test_converter_creation() {
        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();

        let converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Verify initial state
        let stats = converter.get_stats();
        assert_eq!(stats.current_pc, 0);
        assert_eq!(stats.current_block, None);
        assert_eq!(stats.function_index, None);
        assert!(!stats.has_hbc_context);
    }

    #[test]
    fn test_converter_state_management() {
        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();

        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test state updates
        converter.set_current_pc(100);
        converter.set_current_block(42);

        let stats = converter.get_stats();
        assert_eq!(stats.current_pc, 100);
        assert_eq!(stats.current_block, Some(42));
    }

    #[test]
    fn test_converter_reset() {
        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let mut context = ExpressionContext::new();
        context.set_function_index(5);

        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        converter.set_current_pc(100);
        converter.set_current_block(42);
        converter.register_manager_mut().generate_temp_var();

        converter.reset();

        let stats = converter.get_stats();
        assert_eq!(stats.current_pc, 0);
        assert_eq!(stats.current_block, None);
        // Function index should be preserved
        assert_eq!(stats.function_index, Some(5));
    }

    #[test]
    fn test_expression_type_detection() {
        // Test that our generated expression metadata works
        use crate::generated::generated_traits::get_expression_type;

        assert_eq!(
            get_expression_type("Add"),
            ExpressionType::Binary(BinaryOperator::Addition)
        );
        assert_eq!(
            get_expression_type("Sub"),
            ExpressionType::Binary(BinaryOperator::Subtraction)
        );
        assert_eq!(
            get_expression_type("LoadConstTrue"),
            ExpressionType::Literal(LiteralType::Boolean)
        );
        assert_eq!(
            get_expression_type("Not"),
            ExpressionType::Unary(UnaryOperator::LogicalNot)
        );
        assert_eq!(
            get_expression_type("Inc"),
            ExpressionType::Update(UpdateOperator::Increment)
        );
        assert_eq!(
            get_expression_type("UnknownInstruction"),
            ExpressionType::Other
        );
    }

    #[test]
    fn test_variable_operation_handlers() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test Mov instruction
        let mov_instruction = UnifiedInstruction::Mov {
            operand_0: 1,
            operand_1: 2,
        };
        let result = converter.convert_instruction(&mov_instruction);
        assert!(
            result.is_ok(),
            "Mov instruction should convert successfully"
        );

        // Test LoadParam instruction
        let load_param_instruction = UnifiedInstruction::LoadParam {
            operand_0: 0,
            operand_1: 1,
        };
        let result = converter.convert_instruction(&load_param_instruction);
        assert!(
            result.is_ok(),
            "LoadParam instruction should convert successfully"
        );

        // Test GetEnvironment instruction
        let get_env_instruction = UnifiedInstruction::GetEnvironment {
            operand_0: 3,
            operand_1: 0,
        };
        let result = converter.convert_instruction(&get_env_instruction);
        assert!(
            result.is_ok(),
            "GetEnvironment instruction should convert successfully"
        );

        // Test LoadFromEnvironment instruction
        let load_from_env_instruction = UnifiedInstruction::LoadFromEnvironment {
            operand_0: 4,
            operand_1: 3,
            operand_2: 1,
        };
        let result = converter.convert_instruction(&load_from_env_instruction);
        assert!(
            result.is_ok(),
            "LoadFromEnvironment instruction should convert successfully"
        );

        // Test StoreToEnvironment instruction (should return an error as it's not an expression)
        let store_to_env_instruction = UnifiedInstruction::StoreToEnvironment {
            operand_0: 3,
            operand_1: 1,
            operand_2: 4,
        };
        let result = converter.convert_instruction(&store_to_env_instruction);
        assert!(
            result.is_err(),
            "StoreToEnvironment should return error as it's not an expression"
        );

        match result {
            Err(ConversionError::UnsupportedInstruction(msg)) => {
                assert!(
                    msg.contains("StoreToEnvironment"),
                    "Error should mention StoreToEnvironment"
                );
            }
            _ => panic!("Expected UnsupportedInstruction error"),
        }
    }

    #[test]
    fn test_register_tracking_in_variable_operations() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test that Mov instruction tracks register usage
        let mov_instruction = UnifiedInstruction::Mov {
            operand_0: 5,
            operand_1: 10,
        };
        converter.convert_instruction(&mov_instruction).unwrap();

        // Check that the source register is now tracked
        let stats = converter.get_stats();
        assert!(
            stats.register_stats.total_registers >= 1,
            "Should track at least one register"
        );

        // Test that LoadParam marks register as parameter
        let load_param_instruction = UnifiedInstruction::LoadParam {
            operand_0: 0,
            operand_1: 0,
        };
        converter
            .convert_instruction(&load_param_instruction)
            .unwrap();

        let stats = converter.get_stats();
        assert!(
            stats.register_stats.parameter_count >= 1,
            "Should have at least one parameter register"
        );
    }

    #[test]
    fn test_member_expression_handlers() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test GetByVal instruction (obj[key])
        let get_by_val_instruction = UnifiedInstruction::GetByVal {
            operand_0: 0, // destination
            operand_1: 1, // object register
            operand_2: 2, // property register
        };
        let result = converter.convert_instruction(&get_by_val_instruction);
        assert!(
            result.is_ok(),
            "GetByVal instruction should convert successfully"
        );

        // Test DelByVal instruction (delete obj[key])
        let del_by_val_instruction = UnifiedInstruction::DelByVal {
            operand_0: 3, // destination
            operand_1: 1, // object register
            operand_2: 2, // property register
        };
        let result = converter.convert_instruction(&del_by_val_instruction);
        assert!(
            result.is_ok(),
            "DelByVal instruction should convert successfully"
        );

        // Test PutByVal instruction (should return error as it's a statement)
        let put_by_val_instruction = UnifiedInstruction::PutByVal {
            operand_0: 1, // object register
            operand_1: 2, // property register
            operand_2: 4, // value register
        };
        let result = converter.convert_instruction(&put_by_val_instruction);
        assert!(
            result.is_err(),
            "PutByVal should return error as it's not an expression"
        );

        match result {
            Err(ConversionError::UnsupportedInstruction(msg)) => {
                assert!(msg.contains("PutByVal"), "Error should mention PutByVal");
            }
            _ => panic!("Expected UnsupportedInstruction error"),
        }
    }

    // TODO (AST-15): Create test helpers for generating minimal HBC files
    // Priority: Medium - Essential for comprehensive integration testing
    // Should provide utilities to create HBC files with known string/bigint tables

    #[test]
    fn test_call_expression_handlers() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test Call instruction (function(args...))
        let call_instruction = UnifiedInstruction::Call {
            operand_0: 5, // function register
            operand_1: 2, // argument count
            operand_2: 0, // reserved
        };
        let result = converter.convert_instruction(&call_instruction);
        assert!(
            result.is_ok(),
            "Call instruction should convert successfully"
        );

        // Test CallLong instruction
        let call_long_instruction = UnifiedInstruction::CallLong {
            operand_0: 10, // function register
            operand_1: 3,  // argument count
            operand_2: 0,  // reserved
        };
        let result = converter.convert_instruction(&call_long_instruction);
        assert!(
            result.is_ok(),
            "CallLong instruction should convert successfully"
        );

        // Test fixed argument calls
        let call1_instruction = UnifiedInstruction::Call1 {
            operand_0: 1, // function register
            operand_1: 2, // arg1 register
            operand_2: 0, // reserved
        };
        let result = converter.convert_instruction(&call1_instruction);
        assert!(
            result.is_ok(),
            "Call1 instruction should convert successfully"
        );

        let call2_instruction = UnifiedInstruction::Call2 {
            operand_0: 3, // function register
            operand_1: 4, // arg1 register
            operand_2: 5, // arg2 register
            operand_3: 0, // reserved
        };
        let result = converter.convert_instruction(&call2_instruction);
        assert!(
            result.is_ok(),
            "Call2 instruction should convert successfully"
        );

        let call3_instruction = UnifiedInstruction::Call3 {
            operand_0: 6, // function register
            operand_1: 7, // arg1 register
            operand_2: 8, // arg2 register
            operand_3: 9, // arg3 register
            operand_4: 0, // reserved
        };
        let result = converter.convert_instruction(&call3_instruction);
        assert!(
            result.is_ok(),
            "Call3 instruction should convert successfully"
        );

        let call4_instruction = UnifiedInstruction::Call4 {
            operand_0: 10, // function register
            operand_1: 11, // arg1 register
            operand_2: 12, // arg2 register
            operand_3: 13, // arg3 register
            operand_4: 14, // arg4 register
            operand_5: 0,  // reserved
        };
        let result = converter.convert_instruction(&call4_instruction);
        assert!(
            result.is_ok(),
            "Call4 instruction should convert successfully"
        );
    }

    #[test]
    fn test_call_direct_expression_handlers() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test CallDirect instruction
        let call_direct_instruction = UnifiedInstruction::CallDirect {
            operand_0: 42, // function index
            operand_1: 2,  // argument count
            operand_2: 0,  // reserved
        };
        let result = converter.convert_instruction(&call_direct_instruction);
        assert!(
            result.is_ok(),
            "CallDirect instruction should convert successfully"
        );

        // Test CallDirectLongIndex instruction
        let call_direct_long_instruction = UnifiedInstruction::CallDirectLongIndex {
            operand_0: 0,    // destination register
            operand_1: 1,    // argument count
            operand_2: 1000, // function index (u32)
        };
        let result = converter.convert_instruction(&call_direct_long_instruction);
        assert!(
            result.is_ok(),
            "CallDirectLongIndex instruction should convert successfully"
        );
    }

    #[test]
    fn test_construct_expression_handlers() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test Construct instruction (new Constructor(args...))
        let construct_instruction = UnifiedInstruction::Construct {
            operand_0: 5, // constructor register
            operand_1: 2, // argument count
            operand_2: 0, // reserved
        };
        let result = converter.convert_instruction(&construct_instruction);
        assert!(
            result.is_ok(),
            "Construct instruction should convert successfully"
        );

        // Test ConstructLong instruction
        let construct_long_instruction = UnifiedInstruction::ConstructLong {
            operand_0: 10, // constructor register
            operand_1: 3,  // argument count
            operand_2: 0,  // reserved
        };
        let result = converter.convert_instruction(&construct_long_instruction);
        assert!(
            result.is_ok(),
            "ConstructLong instruction should convert successfully"
        );
    }

    #[test]
    fn test_call_builtin_expression_handlers() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test CallBuiltin instruction
        let call_builtin_instruction = UnifiedInstruction::CallBuiltin {
            operand_0: 15, // builtin index
            operand_1: 1,  // argument count
            operand_2: 0,  // reserved
        };
        let result = converter.convert_instruction(&call_builtin_instruction);
        assert!(
            result.is_ok(),
            "CallBuiltin instruction should convert successfully"
        );

        // Test CallBuiltinLong instruction
        let call_builtin_long_instruction = UnifiedInstruction::CallBuiltinLong {
            operand_0: 255, // builtin index
            operand_1: 3,   // argument count
            operand_2: 0,   // reserved
        };
        let result = converter.convert_instruction(&call_builtin_long_instruction);
        assert!(
            result.is_ok(),
            "CallBuiltinLong instruction should convert successfully"
        );
    }

    #[test]
    fn test_call_register_tracking() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test that Call instruction tracks register usage for function and arguments
        let call_instruction = UnifiedInstruction::Call {
            operand_0: 1, // function register
            operand_1: 2, // argument count (args in registers 2, 3)
            operand_2: 0,
        };
        converter.convert_instruction(&call_instruction).unwrap();

        // Check that registers are tracked
        let stats = converter.get_stats();
        assert!(
            stats.register_stats.total_registers >= 3,
            "Should track function + argument registers"
        );

        // Test that Construct instruction tracks register usage
        let construct_instruction = UnifiedInstruction::Construct {
            operand_0: 5, // constructor register
            operand_1: 1, // argument count (arg in register 6)
            operand_2: 0,
        };
        converter
            .convert_instruction(&construct_instruction)
            .unwrap();

        let stats = converter.get_stats();
        assert!(
            stats.register_stats.total_registers >= 5,
            "Should track constructor + argument registers"
        );
    }

    #[test]
    fn test_object_literal_handlers() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test NewObject instruction (empty object {})
        let new_object_instruction = UnifiedInstruction::NewObject {
            operand_0: 5, // destination register
        };
        let result = converter.convert_instruction(&new_object_instruction);
        assert!(
            result.is_ok(),
            "NewObject instruction should convert successfully"
        );

        // Test NewObjectWithParent instruction (Object.create(parent))
        let new_object_with_parent_instruction = UnifiedInstruction::NewObjectWithParent {
            operand_0: 6, // destination register
            operand_1: 3, // parent register
        };
        let result = converter.convert_instruction(&new_object_with_parent_instruction);
        assert!(
            result.is_ok(),
            "NewObjectWithParent instruction should convert successfully"
        );

        // Test NewObjectWithBuffer instruction
        let new_object_with_buffer_instruction = UnifiedInstruction::NewObjectWithBuffer {
            operand_0: 7,  // destination register
            operand_1: 2,  // shape table index
            operand_2: 10, // key buffer index
            operand_3: 20, // value buffer index
            operand_4: 3,  // property count
        };
        let result = converter.convert_instruction(&new_object_with_buffer_instruction);
        assert!(
            result.is_ok(),
            "NewObjectWithBuffer instruction should convert successfully"
        );

        // Test NewObjectWithBufferLong instruction
        let new_object_with_buffer_long_instruction = UnifiedInstruction::NewObjectWithBufferLong {
            operand_0: 8,   // destination register
            operand_1: 2,   // shape table index
            operand_2: 100, // key buffer index (u32)
            operand_3: 200, // value buffer index (u32)
            operand_4: 5,   // property count (u32)
        };
        let result = converter.convert_instruction(&new_object_with_buffer_long_instruction);
        assert!(
            result.is_ok(),
            "NewObjectWithBufferLong instruction should convert successfully"
        );
    }

    #[test]
    fn test_array_literal_handlers() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test NewArray instruction (empty array [])
        let new_array_instruction = UnifiedInstruction::NewArray {
            operand_0: 10, // destination register
            operand_1: 16, // size hint
        };
        let result = converter.convert_instruction(&new_array_instruction);
        assert!(
            result.is_ok(),
            "NewArray instruction should convert successfully"
        );

        // Test NewArrayWithBuffer instruction
        let new_array_with_buffer_instruction = UnifiedInstruction::NewArrayWithBuffer {
            operand_0: 11, // destination register
            operand_1: 4,  // size hint
            operand_2: 50, // buffer index
            operand_3: 4,  // element count
        };
        let result = converter.convert_instruction(&new_array_with_buffer_instruction);
        assert!(
            result.is_ok(),
            "NewArrayWithBuffer instruction should convert successfully"
        );

        // Test NewArrayWithBufferLong instruction
        let new_array_with_buffer_long_instruction = UnifiedInstruction::NewArrayWithBufferLong {
            operand_0: 12,  // destination register
            operand_1: 10,  // size hint
            operand_2: 500, // buffer index (u32)
            operand_3: 10,  // element count (u32)
        };
        let result = converter.convert_instruction(&new_array_with_buffer_long_instruction);
        assert!(
            result.is_ok(),
            "NewArrayWithBufferLong instruction should convert successfully"
        );

        // Test PutOwnByIndex instruction (should return error as it's a statement)
        let put_own_by_index_instruction = UnifiedInstruction::PutOwnByIndex {
            operand_0: 11, // array register
            operand_1: 15, // value register
            operand_2: 0,  // index
        };
        let result = converter.convert_instruction(&put_own_by_index_instruction);
        assert!(
            result.is_err(),
            "PutOwnByIndex should return error as it's not an expression"
        );

        match result {
            Err(ConversionError::UnsupportedInstruction(msg)) => {
                assert!(
                    msg.contains("PutOwnByIndex"),
                    "Error should mention PutOwnByIndex"
                );
            }
            _ => panic!("Expected UnsupportedInstruction error"),
        }
    }

    #[test]
    fn test_object_creation_register_tracking() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test that NewObjectWithParent tracks parent register
        let new_object_with_parent_instruction = UnifiedInstruction::NewObjectWithParent {
            operand_0: 2, // destination register
            operand_1: 1, // parent register
        };
        converter
            .convert_instruction(&new_object_with_parent_instruction)
            .unwrap();

        // Check that parent register is tracked
        let stats = converter.get_stats();
        assert!(
            stats.register_stats.total_registers >= 1,
            "Should track parent register"
        );
    }

    #[test]
    fn test_control_flow_expression_handlers() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test JmpTrue instruction
        let jmp_true_instruction = UnifiedInstruction::JmpTrue {
            operand_0: 10, // target offset
            operand_1: 5,  // condition register
        };
        let result = converter.convert_instruction(&jmp_true_instruction);
        assert!(
            result.is_ok(),
            "JmpTrue instruction should convert successfully"
        );

        // Test JmpTrueLong instruction
        let jmp_true_long_instruction = UnifiedInstruction::JmpTrueLong {
            operand_0: 1000, // target offset (u32)
            operand_1: 3,    // condition register
        };
        let result = converter.convert_instruction(&jmp_true_long_instruction);
        assert!(
            result.is_ok(),
            "JmpTrueLong instruction should convert successfully"
        );

        // Test JmpFalse instruction
        let jmp_false_instruction = UnifiedInstruction::JmpFalse {
            operand_0: 20, // target offset
            operand_1: 8,  // condition register
        };
        let result = converter.convert_instruction(&jmp_false_instruction);
        assert!(
            result.is_ok(),
            "JmpFalse instruction should convert successfully"
        );

        // Test JmpFalseLong instruction
        let jmp_false_long_instruction = UnifiedInstruction::JmpFalseLong {
            operand_0: 2000, // target offset (u32)
            operand_1: 12,   // condition register
        };
        let result = converter.convert_instruction(&jmp_false_long_instruction);
        assert!(
            result.is_ok(),
            "JmpFalseLong instruction should convert successfully"
        );
    }

    #[test]
    fn test_conditional_jump_undefined_handlers() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test JmpUndefined instruction
        let jmp_undefined_instruction = UnifiedInstruction::JmpUndefined {
            operand_0: 30, // target offset
            operand_1: 7,  // variable register
        };
        let result = converter.convert_instruction(&jmp_undefined_instruction);
        assert!(
            result.is_ok(),
            "JmpUndefined instruction should convert successfully"
        );

        // Test JmpUndefinedLong instruction
        let jmp_undefined_long_instruction = UnifiedInstruction::JmpUndefinedLong {
            operand_0: 3000, // target offset (u32)
            operand_1: 15,   // variable register
        };
        let result = converter.convert_instruction(&jmp_undefined_long_instruction);
        assert!(
            result.is_ok(),
            "JmpUndefinedLong instruction should convert successfully"
        );
    }

    #[test]
    fn test_control_flow_register_tracking() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test that conditional jump instructions track register usage
        let jmp_true_instruction = UnifiedInstruction::JmpTrue {
            operand_0: 50, // target offset
            operand_1: 4,  // condition register
        };
        converter.convert_instruction(&jmp_true_instruction).unwrap();

        // Check that condition register is tracked
        let stats = converter.get_stats();
        assert!(
            stats.register_stats.total_registers >= 1,
            "Should track condition register"
        );

        // Test that JmpUndefined tracks register usage
        let jmp_undefined_instruction = UnifiedInstruction::JmpUndefined {
            operand_0: 60, // target offset
            operand_1: 9,  // variable register
        };
        converter
            .convert_instruction(&jmp_undefined_instruction)
            .unwrap();

        let stats = converter.get_stats();
        assert!(
            stats.register_stats.total_registers >= 2,
            "Should track both condition and variable registers"
        );
    }

    #[test]
    fn test_logical_expression_utility_methods() {
        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        let span = Span::default();

        // Test logical expression creation - create fresh expressions for each test
        let left_expr1 = ast_builder.expression_boolean_literal(span, true);
        let right_expr1 = ast_builder.expression_boolean_literal(span, false);
        let and_expr = converter.create_logical_expression(
            left_expr1,
            LogicalOperator::And,
            right_expr1,
        );
        // Verify it's a logical expression by checking if it compiles
        assert!(matches!(
            and_expr,
            Expression::LogicalExpression(_)
        ), "Should create logical AND expression");

        let left_expr2 = ast_builder.expression_boolean_literal(span, true);
        let right_expr2 = ast_builder.expression_boolean_literal(span, false);
        let or_expr = converter.create_logical_expression(
            left_expr2,
            LogicalOperator::Or,
            right_expr2,
        );
        assert!(matches!(
            or_expr,
            Expression::LogicalExpression(_)
        ), "Should create logical OR expression");

        let left_expr3 = ast_builder.expression_boolean_literal(span, true);
        let right_expr3 = ast_builder.expression_boolean_literal(span, false);
        let coalesce_expr = converter.create_logical_expression(
            left_expr3,
            LogicalOperator::Coalesce,
            right_expr3,
        );
        assert!(matches!(
            coalesce_expr,
            Expression::LogicalExpression(_)
        ), "Should create logical coalesce expression");

        // Test conditional expression creation
        let condition_expr = ast_builder.expression_boolean_literal(span, true);
        let left_expr4 = ast_builder.expression_boolean_literal(span, true);
        let right_expr4 = ast_builder.expression_boolean_literal(span, false);
        let ternary_expr = converter.create_conditional_expression(
            condition_expr,
            left_expr4,
            right_expr4,
        );
        assert!(matches!(
            ternary_expr,
            Expression::ConditionalExpression(_)
        ), "Should create conditional (ternary) expression");
    }

    #[test]
    fn test_logical_operator_enum() {
        // Test LogicalOperator enum variants
        assert_eq!(LogicalOperator::And, LogicalOperator::And);
        assert_eq!(LogicalOperator::Or, LogicalOperator::Or);
        assert_eq!(LogicalOperator::Coalesce, LogicalOperator::Coalesce);

        assert_ne!(LogicalOperator::And, LogicalOperator::Or);
        assert_ne!(LogicalOperator::Or, LogicalOperator::Coalesce);
        assert_ne!(LogicalOperator::And, LogicalOperator::Coalesce);
    }

    #[test]
    fn test_arithmetic_instruction_integration() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test Add instruction integration
        let add_instruction = UnifiedInstruction::Add {
            operand_0: 5,
            operand_1: 1,
            operand_2: 2,
        };

        let result = converter.convert_instruction(&add_instruction);
        assert!(result.is_ok(), "Add instruction should convert successfully");
        
        let expr = result.unwrap();
        assert!(matches!(expr, Expression::BinaryExpression(_)), 
               "Add should produce binary expression");

        // Verify register tracking worked
        let stats = converter.get_stats();
        assert!(stats.register_stats.total_registers > 0, "Should track operand registers");
    }

    #[test]
    fn test_constant_loading_integration() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test various constant types
        let test_cases = vec![
            (UnifiedInstruction::LoadConstTrue { operand_0: 1 }, "BooleanLiteral"),
            (UnifiedInstruction::LoadConstFalse { operand_0: 2 }, "BooleanLiteral"),
            (UnifiedInstruction::LoadConstNull { operand_0: 3 }, "NullLiteral"),
            (UnifiedInstruction::LoadConstUndefined { operand_0: 4 }, "Identifier"),
            (UnifiedInstruction::LoadConstUInt8 { operand_0: 5, operand_1: 42 }, "NumericLiteral"),
        ];

        for (instruction, expected_type) in test_cases {
            let result = converter.convert_instruction(&instruction);
            assert!(result.is_ok(), "Constant load should convert successfully: {:?}", instruction);
            
            let expr = result.unwrap();
            let expr_name = match expr {
                Expression::BooleanLiteral(_) => "BooleanLiteral",
                Expression::NullLiteral(_) => "NullLiteral", 
                Expression::Identifier(_) => "Identifier",
                Expression::NumericLiteral(_) => "NumericLiteral",
                _ => "Other",
            };
            assert_eq!(expr_name, expected_type, "Expected {} for {:?}", expected_type, instruction);
        }
    }

    #[test]
    fn test_member_access_integration() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test GetByVal (computed member access)
        let getbyval_instruction = UnifiedInstruction::GetByVal {
            operand_0: 3,
            operand_1: 1,  // object register
            operand_2: 2,  // property register
        };

        let result = converter.convert_instruction(&getbyval_instruction);
        assert!(result.is_ok(), "GetByVal should convert successfully");
        
        let expr = result.unwrap();
        assert!(matches!(expr, Expression::ComputedMemberExpression(_)), 
               "GetByVal should produce computed member expression");

        // Verify both object and property registers were tracked
        let stats = converter.get_stats();
        assert!(stats.register_stats.total_registers >= 2, "Should track object and property registers");
    }

    #[test]
    fn test_call_expression_integration() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test Call instruction
        let call_instruction = UnifiedInstruction::Call {
            operand_0: 4,
            operand_1: 1,  // function register
            operand_2: 2,  // arg count
        };

        let result = converter.convert_instruction(&call_instruction);
        assert!(result.is_ok(), "Call should convert successfully");
        
        let expr = result.unwrap();
        assert!(matches!(expr, Expression::CallExpression(_)), 
               "Call should produce call expression");

        // Verify function register was tracked
        let stats = converter.get_stats();
        assert!(stats.register_stats.total_registers >= 1, "Should track at least function register");
    }

    #[test]
    fn test_unary_expression_integration() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test various unary operations
        let test_cases = vec![
            UnifiedInstruction::Negate { operand_0: 2, operand_1: 1 },
            UnifiedInstruction::Not { operand_0: 3, operand_1: 1 },
            UnifiedInstruction::BitNot { operand_0: 4, operand_1: 1 },
            UnifiedInstruction::TypeOf { operand_0: 5, operand_1: 1 },
        ];

        for instruction in test_cases {
            let result = converter.convert_instruction(&instruction);
            assert!(result.is_ok(), "Unary instruction should convert successfully: {:?}", instruction);
            
            let expr = result.unwrap();
            assert!(matches!(expr, Expression::UnaryExpression(_)), 
                   "Unary instruction should produce unary expression: {:?}", instruction);
        }
    }

    #[test]
    fn test_update_expression_integration() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test increment/decrement operations
        let test_cases = vec![
            UnifiedInstruction::Inc { operand_0: 2, operand_1: 1 },
            UnifiedInstruction::Dec { operand_0: 3, operand_1: 1 },
        ];

        for instruction in test_cases {
            let result = converter.convert_instruction(&instruction);
            assert!(result.is_ok(), "Update instruction should convert successfully: {:?}", instruction);
            
            let expr = result.unwrap();
            assert!(matches!(expr, Expression::UpdateExpression(_)), 
                   "Update instruction should produce update expression: {:?}", instruction);
        }
    }

    #[test]
    fn test_performance_targets() {
        use crate::generated::unified_instructions::UnifiedInstruction;
        use std::time::Instant;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Create a sample of various instruction types for performance testing
        let instructions = vec![
            UnifiedInstruction::Add { operand_0: 10, operand_1: 1, operand_2: 2 },
            UnifiedInstruction::LoadConstTrue { operand_0: 11 },
            UnifiedInstruction::Mov { operand_0: 12, operand_1: 11 },
            UnifiedInstruction::GetByVal { operand_0: 13, operand_1: 10, operand_2: 12 },
            UnifiedInstruction::Call { operand_0: 14, operand_1: 13, operand_2: 1 },
            UnifiedInstruction::Negate { operand_0: 15, operand_1: 14 },
            UnifiedInstruction::Inc { operand_0: 16, operand_1: 15 },
            UnifiedInstruction::LoadConstUInt8 { operand_0: 17, operand_1: 42 },
            UnifiedInstruction::Not { operand_0: 18, operand_1: 17 },
            UnifiedInstruction::Sub { operand_0: 19, operand_1: 18, operand_2: 16 },
        ];

        // Warm up
        for instruction in &instructions {
            let _ = converter.convert_instruction(instruction);
        }

        // Performance test: convert each instruction multiple times and measure average
        let iterations = 1000;
        let mut total_duration = std::time::Duration::new(0, 0);
        let mut successful_conversions = 0;

        for _ in 0..iterations {
            for instruction in &instructions {
                let start = Instant::now();
                let result = converter.convert_instruction(instruction);
                let duration = start.elapsed();
                
                total_duration += duration;
                
                if result.is_ok() {
                    successful_conversions += 1;
                }
            }
        }

        let total_instructions = iterations * instructions.len();
        let average_time_per_instruction = total_duration / total_instructions as u32;
        let average_time_micros = average_time_per_instruction.as_micros();

        println!("Performance Results:");
        println!("  Total instructions processed: {}", total_instructions);
        println!("  Successful conversions: {}", successful_conversions);
        println!("  Average time per instruction: {}s", average_time_micros);
        println!("  Target: <1000s (1ms) per instruction");

        // Verify performance target: <1ms per instruction
        assert!(
            average_time_micros < 1000, 
            "Performance target not met: {}s per instruction (target: <1000s)", 
            average_time_micros
        );

        // Verify all conversions were successful
        assert_eq!(
            successful_conversions, total_instructions,
            "Not all instructions converted successfully: {}/{}", 
            successful_conversions, total_instructions
        );
    }

    #[test]
    fn test_instruction_conversion_comprehensive() {
        use crate::generated::unified_instructions::UnifiedInstruction;

        let allocator = Allocator::default();
        let ast_builder = OxcAstBuilder::new(&allocator);
        let context = ExpressionContext::new();
        let mut converter = InstructionToExpressionConverter::new(&ast_builder, context);

        // Test a variety of instructions to ensure comprehensive coverage
        let instructions = vec![
            UnifiedInstruction::Add { operand_0: 10, operand_1: 1, operand_2: 2 },
            UnifiedInstruction::LoadConstTrue { operand_0: 11 },
            UnifiedInstruction::Mov { operand_0: 12, operand_1: 11 },
            UnifiedInstruction::GetByVal { operand_0: 13, operand_1: 10, operand_2: 12 },
            UnifiedInstruction::Call { operand_0: 14, operand_1: 13, operand_2: 1 },
        ];

        let mut successful_conversions = 0;
        
        for instruction in instructions {
            let result = converter.convert_instruction(&instruction);
            if result.is_ok() {
                successful_conversions += 1;
            }
        }

        assert_eq!(successful_conversions, 5, "All test instructions should convert successfully");
        
        // Verify converter tracked multiple registers
        let stats = converter.get_stats();
        assert!(stats.register_stats.total_registers > 0, "Should have tracked multiple registers");
    }
}
